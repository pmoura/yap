/*************************************************************************
*									 *
  *	 YAP Prolog 							 *
*									 *
  *	Yap Prolog was developed at NCCUP - Universidade do Porto	 *
*									 *
* Copyright L.Damas, V.S.Costa and Universidade do Porto 1985-1997	 *
*									 *
**************************************************************************
*									 *
* File:		myddas_assert_predicates.yap	                         *
* Last rev:							         *
* mods:									 *
 * comments:	Predicates that assert other for the MyDDAS Interface	 *
*									 *
*************************************************************************/

:- module(myddas_assert_predicates,[
				    db_assert/1,
				    db_assert/2,
				    db_import/2,
				    db_import/3,
				    db_view/2,
				    db_view/3,
				    db_insert/2,
				    db_insert/3,
				    db_update/2,
				    db_abolish/2,
				    db_listing/0,
				    db_listing/1,
				    relation/3,
				    goal2sql/2

				   ]).
:- dynamic relation/3.

:- dynamic translate/3.

:- use_module( library(lists)).
:- use_module( library(maplist)).

:- use_module(myddas_errors,[
			     '$error_checks'/1
			     ]).

:- use_module(myddas_util_predicates).

:- use_module(myddas_mysql).

 :- use_module(myddas_sqlite3).

:- use_module(myddas_odbc).
:- use_module(myddas_postgres).

:- use_module(myddas_core).


:- meta_predicate db_import(+,+,:), db_import(+,:).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% db_import/3
% db_import/2
%
db_import(RelationName,PredName0):-
	db_import(myddas,RelationName,PredName0).
db_import(Connection,RelationName,PredName0) :-
	'$error_checks'(db_import(Connection,RelationName,PredName0)),
	get_value(Connection,Con),
	table_arity( Connection, RelationName, Arity ),
	strip_module(PredName0, Module, PredName),
	\+ c_db_check_if_exists_pred(PredName,Arity,Module),
        c_db_connection_type(Con,ConType),
	table_attributes( ConType, Con, RelationName, FieldNamesList, TypesList ),
	assert(myddas_yap2sql:relation(Module,PredName,Arity,RelationName, FieldNamesList, TypesList )),
	functor(Goal,PredName,Arity),
	assert((Module:Goal :- goal2sql(Connection,Module:Goal))),
    !.

goal2sql(Connection, Module:Goal) :-
	functor(Goal,PredName,Arity),
	myddas_yap2sql:relation(Module,PredName,Arity,RelationName, FieldNamesList, _TypesList ),
	copy_term(Goal,NGoal),
	copy_term(Goal,TmpGoal),
	TmpGoal =.. [PredName|Args],
	foldl3(apply(RelationName), Args, FieldNamesList,BoundVars,[], Outputs, [], Joins, []),
	att_names(Outputs, Selected),
	bindings( BoundVars, Selects),
	joins( Joins, CodeJoins),
	format(atom(SQL), 'select ~s from ~s ~s ~s;~n', [Selected, RelationName, CodeJoins, Selects]),
	writeln(SQL),
	term_variables(Goal,FreeVars),
	asserta((Module:Goal :- NGoal =@= Goal,!,
			       db_sql(Connection, SQL,FreeVars))),
	db_sql(Connection, SQL,FreeVars).

apply( R,V, A,L, L,  [R:A|Fs], Fs, Os, Os) :-
    var(V),
    !,
    V = '$binding'(R:A).
apply( R, '$binding'(R:A0), A, L , L, Fs, Fs, [(R:A)=(R:A0)|Os], Os) :-
    !.
apply( R,  C, A,[(R:A)=C| L] , L, Fs, Fs, Os, Os) .

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% table_arity :- number of columns in a relation.
%                               %
table_arity( Con, _ConType, RelationName, Arity ) :-
           db_number_of_fields(Con,RelationName,Arity).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


#if MYDDAS_SQLITE3
table_attributes( sqlite3, Con, RelationName, NamesList, TypesList ) :-
    c_sqlite3_get_attributes_types(RelationName,Con,InfoList),
  maplist(new_att(RelationName),InfoList,NamesList, TypesList).

new_att(RelationName,t(N1,Name, Type), Name, Type) :-
    assert(myddas_yap2sql:att(RelationName,N1,Name, Type)).

att_names(L,FieldNames) :-
    att_names_(L,LF,[]),
    atom_list_concat(LF, FieldNames).


att_names_([]) --> [].
att_names_([(R:Name)]) -->
    !,
    [R,'.',Name].
att_names_([(R:Name)|Names]) -->
    [R,'.',Name,', '],
    att_names_(Names).

bindings([],'') :-
    !.
bindings(L,FieldNames) :-
    bindings_(L,LF,[]),
    atom_list_concat(['where '|LF], FieldNames).

bindings_(L,FieldNames) :-
    bindings_(L,LF,[]),
    atom_number(A,Value)},
   [R,'.',Name,' = ', A].
bindings_(Name,R,Value) -->
	[R,'.',Name,' = \'', Value,'\''].

joins(Eqs,Code) :-
    joins_(Eqs, LF,[]),
    atom_list_concat(LF, Code).

joins_([]) -->
    [].
joins_([R:Name=Q:Name2]) -->
    !,
     eq(Name,R,Name2,Q).
joins_([R:Name=Q:Name2|Names]) -->
    eq(Name,R,Name2,Q),
    [',~n '],
    joins_( Names).

eq(A1,R1,A2,R2) -->
    ['inner join ',R1,' on ', R1,'.',A1,' = ',R2,'.',A2].

#else
% table_attributes( _DB, _Con, _RelationName, _NamesList, _TypesList ) :-throw(not_yet)..
#endif

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%a%%%%%%%%%%%%%%%%%%%%%


:- meta_predicate db_view(:,0).
:- meta_predicate db_view(+,:,0).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% db_view/3
% db_view/2
%
db_view(PredName,DbGoal) :-
        db_view(myddas,PredName,DbGoal).
db_view(Connection,PredName,DbGoal) :-
        '$error_checks'(db_view(Connection,PredName,DbGoal)),
        get_value(Connection,Con),

        % get arity of projection term
        functor(PredName,ViewName,Arity),
        db_module(Module),
        not c_db_check_if_exists_pred(ViewName,Arity,Module),

        % This copy_term is done to prevent the unification
        % with top-level variables   A='var('A')' error
        copy_term((PredName,DbGoal),(CopyView,CopyGoal)),

        CopyView=..[ViewName|LA],

        M=myddas_assert_predicates,
        c_db_connection_type(Con,ConType),

        % build view clause
        table_view( ConType, Con, CopyView, CopyGoal, Arity, LA, M, Assert ),
        assert(Module:Assert),
        c_db_add_preds(ViewName,Arity,Module,Con).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% @pred db_insert/3
%
%
db_insert(RelationName,PredName) :-
	db_insert(myddas,RelationName,PredName).
db_insert(Connection,RelationName,PredName) :-
	'$error_checks'(db_insert3(Connection,RelationName,PredName)),
	get_value(Connection,Con),
	c_db_connection_type(Con,ConType),

	% get relation arity
	table_arity( Con, ConType, RelationName, Arity ),
	db_module(Module),
	not c_db_check_if_exists_pred(PredName,Arity,Module),

	R=..[relation,Module,PredName,Arity,RelationName],
	% assert relation fact
	assert(myddas_prolog2sql:R),

	% build PredName functor
	functor(Predicate,PredName,Arity),
	Predicate=..[PredName|LA],

	Size is 2*Arity,
        '$make_a_list'(Size,TypesList),

	% get attributes types in TypesList [field0,type0,field1,type1...]
	% and build PredName clause
	table_insert( ConType, Con, RelationName, TypesList, Predicate, LA, Assert ),
	assert(Module:Assert),
	c_db_add_preds(PredName,Arity,Module,Con).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% db_abolish(+,+)
%
%
db_abolish(Module:PredName,Arity):-!,
	'$error_checks'(db_abolish(Module:PredName,Arity)),
	c_db_delete_predicate(Module,PredName,Arity),
	abolish(Module:PredName,Arity).
db_abolish(PredName,Arity):-
	'$error_checks'(db_abolish(PredName,Arity)),
	db_module(Module),
	c_db_delete_predicate(Module,PredName,Arity),
	abolish(Module:PredName,Arity).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% db_listing.
%
%
db_listing:-
	c_db_connection(Con),
	c_db_preds_conn(Con,Module,Name,Arity),
	listing(Module:Name/Arity),
	fail.
db_listing.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% @pred db_listing(+PredIndicator)
%%
%% describe a table's data.
db_listing(Module:Name/Arity):-!,
	c_db_connection(Con),
	c_db_preds_conn(Con,Module,Name,Arity),
	listing(Module:Name/Arity).
db_listing(Name/Arity):-!,
	c_db_connection(Con),
	c_db_preds_conn(Con,Module,Name,Arity),
	listing(Module:Name/Arity).
db_listing(Name):-
	c_db_connection(Con),
	c_db_preds_conn(Con,Module,Name,Arity),
	listing(Module:Name/Arity).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% table_arity :- number of columns in a relation.
%				%
table_arity( Connection, RelationName, Arity ) :-
	   db_number_of_fields(Connection,RelationName,Arity).

% predicate for DB-> query

#if MYDDAS_MYSQL
table_access_predicate( mysql, Con, Arity, P, LA, M,
			( P :-  '$copy_term_nv'(P,[],G,_),
				  translate(M:G,M:G,Code),
				  queries_atom(Code,FinalSQL),
				  db_my_result_set(Mode),
				  myddas_util_predicates:'$write_or_not'(FinalSQL),
				  c_db_my_query(FinalSQL,ResultSet,Con,Mode,_),
				  !,
				  c_db_my_row(ResultSet,Arity,LA)
			  )).
#endif
#if MYDDAS_POSTGRES
table_access_predicate( postgres, Con, Arity, P, LA, M,
                        M:( P :- myddas_util_predicates:'$copy_term_nv'(P,[],G,_),
                               translate(M:G,M:G,Code),
                               queries_atom(Code,FinalSQL),
                               myddas_postgres:postgres_result_set(Mode),
                               myddas_util_predicates:'$write_or_not'(FinalSQL),
xb                               c_postgres_query(FinalSQL,ResultSet,Con,Mode,_),
                               !,
                               c_postgres_row(ResultSet,Arity,LA) )
		      ).
#endif
#if MYDDAS_SQLITE3
table_access_predicate( sqlite3, Con, Arity, P, LA, M,
                        ( M:P :- (myddas_util_predicates:'$copy_term_nv'(P,[],G,_),
                                      myddas_prolog2sql:translate(M:G,M:G,Code),
                                      myddas_prolog2sql:queries_atom(Code,FinalSQL),
				      myddas_sqlite3:sqlite3_result_set(Mode),
                                      myddas_util_predicates:'$write_or_not'(FinalSQL),
				      myddas_sqlite3:c_sqlite3_query(FinalSQL,ResultSet,Con,Mode,_),
				      !,
				  myddas_sqlite3:sqlite3_row(ResultSet,Arity,LA)
				     ) )).
#endif
#if MYDDAS_ODBC
table_access_predicate( odbc, Con, Arity, P, LA, M,
                        ( P :- (myddas_util_predicates:'$copy_term_nv'(P,[],G,_),
				  myddas_prolog2sql:translate(G,G,Code),
				  queries_atom(M:Code,FinalSQL),
				  myddas_odbc:odbc_result_set(Mode),
				  'myddas_util_predicates:$write_or_not'(FinalSQL),
				  myddas_odbc:c_odbc_query(FinalSQL,ResultSet,Con,Mode,_),
				  !,
				  myddas_odbc:c_odbc_row(ResultSet,Arity,LA)
				 ) )).
#endif

#if MYDDAS_MYSQL
table_insert( mysql, Con, RelationName, TypesList, Predicate, LA,
	      ( Predicate :- myddas_assert_predicates:
	      ( '$get_values_for_insert'(TypesList,LA,ValuesList),
		'$make_atom'(['INSERT INTO `',RelationName,'` VALUES ('|ValuesList],SQL),
		db_my_result_set(Mode),
		'$write_or_not'(SQL),
		c_db_my_query(SQL,_,Con,Mode,_)))
	    ).
#endif
#if MYDDAS_POSTGRES
table_insert( postgres, Con, RelationName, TypesList, Predicate, LA,
              ( Predicate :- myddas_assert_predicates:
              ( '$get_values_for_insert'(TypesList,LA,ValuesList),
                '$make_atom'(['INSERT INTO `',RelationName,'` VALUES ('|ValuesList],SQL),
		postgres_result_set(Mode),
                '$write_or_not'(SQL),
                c_postgres_query(SQL,_,Con,Mode,_)))
            ).
#endif
#if MYDDAS_SQLITE3
table_insert( sqlite3, Con, RelationName, TypesList, Predicate, LA,
	      ( Predicate :- myddas_assert_predicates:
	      ( '$get_values_for_insert'(TypesList,LA,ValuesList),
		'$make_atom'(['INSERT INTO `',RelationName,'` VALUES ('|ValuesList],SQL),
		sqlite3_result_set(Mode),
		'$write_or_not'(SQL),
		c_sqlite3_query(SQL,_,Con,Mode,_)))
	    ).
#endif
#if MYDDAS_ODBC
table_insert( odbc, Con, RelationName, TypesList, Predicate, LA,
	      ( Predicate :- myddas_assert_predicates:
	      ( '$get_values_for_insert'(TypesList,LA,ValuesList),
		'$make_atom'(['INSERT INTO `',RelationName,'` VALUES ('|ValuesList],SQL),
		'$write_or_not'(SQL),
		c_odbc_my_query(SQL,_,_,_,Con)))
	    ).
#endif
#if MYDDAS_MYSQL
table_view( mysql, Con, CopyView, CopyGoal, Arity, LA, M,
          ( CopyView :-
          M:( '$copy_term_nv'(CopyView,[],ProjT,Dic),
              '$copy_term_nv'(CopyGoal,Dic,NG,_),
              translate(ProjT,NG,Code),
              queries_atom(Code,FinalSQL),
              db_my_result_set(Mode),
              '$write_or_not'(FinalSQL),
              c_db_my_query(FinalSQL,ResultSet,Con,Mode,_),
              !,
              c_db_my_row(ResultSet,Arity,LA) ))).
#endif
#if MYDDAS_POSTGRES
table_view( postgres, Con, CopyView, CopyGoal, Arity, LA, M,
            ( CopyView :-
            M:( '$copy_term_nv'(CopyView,[],ProjT,Dic),
                '$copy_term_nv'(CopyGoal,Dic,NG,_),
                translate(ProjT,NG,Code),
                queries_atom(Code,FinalSQL),
                db_my_result_set(Mode),
                '$write_or_not'(FinalSQL),
                c_postgres_query(FinalSQL,ResultSet,Con,Mode,_),
                !,
                c_postgres_row(ResultSet,Arity,LA) ))).
#endif
#if MYDDAS_ODBC
table_view( odbc, Con, CopyView, CopyGoal, Arity, LA, M,
          ( CopyView :-
          M:( '$copy_term_nv'(CopyView,[],ProjT,Dic),
              '$copy_term_nv'(CopyGoal,Dic,NG,_),
              translate(ProjT,NG,Code),
	      length(BindList, Arity ),
              queries_atom(Code,FinalSQL),
              '$write_or_not'(FinalSQL),
              c_odbc_query(FinalSQL,ResultSet,Arity,BindList,Con),
	      !,
	    c_odbc_row(ResultSet,Arity,LA) ))).
#endif
#if MYDDAS_SQLITE3
table_view( sqlite3, Con, CopyView, CopyGoal, Arity, LA, M,
          ( CopyView :-
          M:( '$copy_term_nv'(CopyView,[],ProjT,Dic),
              '$copy_term_nv'(CopyGoal,Dic,NG,_),
              translate(ProjT,NG,Code),
              queries_atom(Code,FinalSQL),
              '$write_or_not'(FinalSQL),
              myddas_sqlite3:c_sqlite3_query(FinalSQL,ResultSet,Con,_,_),
              !,
              myddas_sqlite3:sqlite3_row(ResultSet,Arity,LA) ))).
#endif

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				% db_assert/2
				% db_assert/1
				%
db_assert(PredName):-
	db_assert(myddas,PredName).

db_assert(Connection,PredName):-
	translate(PredName,PredName,Code),
	'$error_checks'(db_assert(Connection,PredName,Code)),
	'$get_values_for_insert'(Code,ValuesList,RelName),
	'$make_atom'(['INSERT INTO `',RelName,'` VALUES '|ValuesList],SQL),
	get_value(Connection,Con),
	c_db_connection_type(Con,ConType),
	'$write_or_not'(SQL),
	( ConType == mysql ->
	  myddas_top_level:db_my_result_set(Mode),
	  c_db_my_query(SQL,_,Con,Mode,_)
	;ConType == postgres ->
	  postgres_result_set(Mode),
	  c_postgres_query(SQL,_,Con,Mode,_)
	;ConType == sqlite3 ->
	  sqlite3_result_set(Mode),
	  myddas_myddas_sqlite3:c_sqlite3_query(SQL,_,Con,Mode,_)
	;
	  c_odbc_query(SQL,_,_,_,Con)
	).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				% db_update/2
				% BUG: db_update dosen't work for this case, just an example
				% db_update(my1,edge(1,3)-edge(99,99)).
				% The case where the set condition is "set" to change all the fields
db_update(Connection,WherePred-SetPred):-
				%TODO: error_checks
	get_value(Connection,Conn),

				% Match and Values must be "unifiable"
	functor(WherePred,PredName,Arity),
	functor(SetPred,PredName,Arity),

	functor(NewRelation,PredName,Arity),

	'$extract_args'(WherePred,1,Arity,WhereArgs),
	'$extract_args'(SetPred,1,Arity,SetArgs),

	copy_term(WhereArgs,WhereArgsTemp),
	NewRelation=..[PredName|WhereArgsTemp],
	translate(NewRelation,NewRelation,Code),

	'$get_values_for_update'(Code,SetArgs,SetCondition,WhereCondition),

	'$get_table_name'(Code,TableName),
	append(SetCondition,WhereCondition,Conditions),
	'$make_atom'(['UPDATE `',TableName,'` '|Conditions],SQL),
	'$write_or_not'(SQL),
	get_value(Connection,Con),
	c_db_connection_type(Con,ConType),
	( ConType == mysql ->
	myddas_top_level:db_my_result_set(Mode),
	  c_db_my_query(SQL,_,Conn,Mode,_)
	;
	  ConType == mysql ->
	postgres_result_set(Mode),
	  c_postgres_query(SQL,_,Conn,Mode,_)
	;
	ConType == sqlite3 ->
	sqlite3_result_set(Mode),
	 myddas_sqlite3:c_sqlite3_query(SQL,_,Conn,Mode,_)
	;
	  ConType == odbc ->
	  c_odbc_query(SQL,_,Conn,Mode,_)
	).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
